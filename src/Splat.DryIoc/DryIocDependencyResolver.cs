// Copyright (c) 2026 ReactiveUI. All rights reserved.
// Licensed to ReactiveUI under one or more agreements.
// ReactiveUI licenses this file to you under the MIT license.
// See the LICENSE file in the project root for full license information.

using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.Linq.Expressions;

using DryIoc;

namespace Splat.DryIoc;

/// <summary>
/// DryIoc implementation for <see cref="IMutableDependencyResolver"/>.
/// https://bitbucket.org/dadhi/dryioc/wiki/Home.
/// </summary>
/// <seealso cref="IDependencyResolver" />
/// <remarks>
/// Initializes a new instance of the <see cref="DryIocDependencyResolver" /> class.
/// </remarks>
/// <param name="container">The container.</param>
public class DryIocDependencyResolver(IContainer? container = null) : IDependencyResolver
{
    private readonly IContainer _container = container ?? new Container();

    /// <inheritdoc />
    public virtual object? GetService(Type? serviceType, string? contract) =>
        GetServices(serviceType, contract).LastOrDefault();

    /// <inheritdoc />
    public virtual IEnumerable<object> GetServices(Type? serviceType, string? contract)
    {
        // When contract is null/empty, get bindings with DefaultKey (auto-generated by AppendNewImplementation)
        if (string.IsNullOrEmpty(contract))
        {
            // Get all bindings that aren't tuple keys (which means they're either DefaultKey or null)
            var bindingsWithDefaultKey = _container.GetServiceRegistrations()
                .Where(x => x.ServiceType == serviceType &&
                           (x.OptionalServiceKey is null ||
                            x.OptionalServiceKey.ToString()!.StartsWith("DefaultKey", StringComparison.Ordinal)))
                .ToList();

            if (bindingsWithDefaultKey.Count == 0)
            {
                return [];
            }

            // Resolve each binding individually
            var results = new List<object>();
            foreach (var binding in bindingsWithDefaultKey)
            {
                var instance = _container.Resolve(serviceType, serviceKey: binding.OptionalServiceKey);
                if (instance is not null)
                {
                    results.Add(instance);
                }
            }

            return results;
        }

        // When contract is provided, resolve with the contract as the service key
        var registeredWithContract = _container.ResolveMany(serviceType, behavior: ResolveManyBehavior.AsFixedArray, serviceKey: contract);
        return registeredWithContract;
    }

    /// <inheritdoc />
    public bool HasRegistration(Type? serviceType, string? contract)
    {
        ArgumentExceptionHelper.ThrowIfNull(serviceType);

        return _container.GetServiceRegistrations().Any(x =>
        {
            if (x.ServiceType != serviceType)
            {
                return false;
            }

            if (contract is null)
            {
                return x.OptionalServiceKey is null ||
                       x.OptionalServiceKey.ToString()!.StartsWith("DefaultKey", StringComparison.Ordinal);
            }

            return x.OptionalServiceKey is string serviceKeyAsString &&
                   contract.Equals(serviceKeyAsString, StringComparison.Ordinal);
        });
    }

    /// <inheritdoc />
    public virtual void Register(Func<object?> factory, Type? serviceType, string? contract)
    {
        ArgumentExceptionHelper.ThrowIfNull(factory);
        ArgumentExceptionHelper.ThrowIfNull(serviceType);

        if (string.IsNullOrEmpty(contract))
        {
            _container.RegisterDelegate(
                serviceType,
                _ => CreateThenConvert(serviceType!, factory),
                ifAlreadyRegistered: IfAlreadyRegistered.AppendNewImplementation);

            return;
        }

        _container.RegisterDelegate(
            serviceType,
            _ => CreateThenConvert(serviceType!, factory),
            ifAlreadyRegistered: IfAlreadyRegistered.Replace,
            serviceKey: contract);
    }

    /// <inheritdoc />
    public virtual void UnregisterCurrent(Type? serviceType, string? contract)
    {
        // Find the LAST matching binding (not the first)
        var matchingBinding = _container.GetServiceRegistrations()
            .LastOrDefault(x =>
            {
                if (x.ServiceType != serviceType)
                {
                    return false;
                }

                if (contract is null)
                {
                    return x.OptionalServiceKey is null ||
                           x.OptionalServiceKey.ToString()!.StartsWith("DefaultKey", StringComparison.Ordinal);
                }

                return x.OptionalServiceKey is string serviceKeyAsString &&
                       contract.Equals(serviceKeyAsString, StringComparison.Ordinal);
            });

        if (!matchingBinding.Equals(default(ServiceRegistrationInfo)))
        {
            // Unregister using the specific binding's key
            if (matchingBinding.OptionalServiceKey is not null)
            {
                _container.Unregister(serviceType, matchingBinding.OptionalServiceKey);
            }
            else
            {
                _container.Unregister(serviceType);
            }
        }
    }

    /// <inheritdoc />
    public virtual void UnregisterAll(Type? serviceType, string? contract)
    {
        // Collect all registrations to unregister first to avoid modifying collection during iteration
        var registrationsToUnregister = _container.GetServiceRegistrations()
            .Where(x =>
            {
                if (x.ServiceType != serviceType)
                {
                    return false;
                }

                if (contract is null)
                {
                    return x.OptionalServiceKey is null ||
                           x.OptionalServiceKey.ToString()!.StartsWith("DefaultKey", StringComparison.Ordinal);
                }

                return x.OptionalServiceKey is string serviceKeyAsString &&
                       contract.Equals(serviceKeyAsString, StringComparison.Ordinal);
            })
            .ToList();

        // Unregister each collected registration
        foreach (var registration in registrationsToUnregister)
        {
            _container.Unregister(serviceType, registration.OptionalServiceKey);
        }
    }

    /// <inheritdoc />
    public virtual IDisposable ServiceRegistrationCallback(Type serviceType, string? contract, Action<IDisposable> callback) => throw new NotImplementedException();

    /// <inheritdoc/>
    public object? GetService(Type? serviceType) =>
        GetService(serviceType, null);

    /// <inheritdoc/>
    public T? GetService<T>() =>
        (T?)GetService(typeof(T), null);

    /// <inheritdoc/>
    public T? GetService<T>(string? contract) =>
        (T?)GetService(typeof(T), contract);

    /// <inheritdoc/>
    public IEnumerable<object> GetServices(Type? serviceType) =>
        GetServices(serviceType, null);

    /// <inheritdoc/>
    public IEnumerable<T> GetServices<T>() =>
        GetServices(typeof(T), null).Cast<T>();

    /// <inheritdoc/>
    public IEnumerable<T> GetServices<T>(string? contract) =>
        GetServices(typeof(T), contract).Cast<T>();

    /// <inheritdoc/>
    public bool HasRegistration(Type? serviceType) =>
        HasRegistration(serviceType, null);

    /// <inheritdoc/>
    public bool HasRegistration<T>() =>
        HasRegistration(typeof(T), null);

    /// <inheritdoc/>
    public bool HasRegistration<T>(string? contract) =>
        HasRegistration(typeof(T), contract);

    /// <inheritdoc/>
    public void Register(Func<object?> factory, Type? serviceType) =>
        Register(factory, serviceType, null);

    /// <inheritdoc/>
    public void Register<T>(Func<T?> factory) =>
        Register(() => factory(), typeof(T), null);

    /// <inheritdoc/>
    public void Register<T>(Func<T?> factory, string? contract) =>
        Register(() => factory(), typeof(T), contract);

    /// <inheritdoc/>
    public void UnregisterCurrent(Type? serviceType) =>
        UnregisterCurrent(serviceType, null);

    /// <inheritdoc/>
    public void UnregisterCurrent<T>() =>
        UnregisterCurrent(typeof(T), null);

    /// <inheritdoc/>
    public void UnregisterCurrent<T>(string? contract) =>
        UnregisterCurrent(typeof(T), contract);

    /// <inheritdoc/>
    public void UnregisterAll(Type? serviceType) =>
        UnregisterAll(serviceType, null);

    /// <inheritdoc/>
    public void UnregisterAll<T>() =>
        UnregisterAll(typeof(T), null);

    /// <inheritdoc/>
    public void UnregisterAll<T>(string? contract) =>
        UnregisterAll(typeof(T), contract);

    /// <inheritdoc/>
    public IDisposable ServiceRegistrationCallback(Type serviceType, Action<IDisposable> callback) =>
        ServiceRegistrationCallback(serviceType, null, callback);

    /// <inheritdoc/>
    public IDisposable ServiceRegistrationCallback<T>(Action<IDisposable> callback) =>
        ServiceRegistrationCallback(typeof(T), null, callback);

    /// <inheritdoc/>
    public IDisposable ServiceRegistrationCallback<T>(string? contract, Action<IDisposable> callback) =>
        ServiceRegistrationCallback(typeof(T), contract, callback);

    /// <inheritdoc/>
    void IMutableDependencyResolver.Register<TService, TImplementation>() =>
        _container.RegisterDelegate<TService>(
            _ => new TImplementation(),
            ifAlreadyRegistered: IfAlreadyRegistered.AppendNewImplementation);

    /// <inheritdoc/>
    void IMutableDependencyResolver.Register<TService, TImplementation>(string? contract)
    {
        if (string.IsNullOrEmpty(contract))
        {
            _container.RegisterDelegate<TService>(
                _ => new TImplementation(),
                ifAlreadyRegistered: IfAlreadyRegistered.AppendNewImplementation);
            return;
        }

        _container.RegisterDelegate<TService>(
            _ => new TImplementation(),
            ifAlreadyRegistered: IfAlreadyRegistered.Replace,
            serviceKey: contract);
    }

    /// <inheritdoc/>
    public void RegisterConstant<T>(T? value)
        where T : class
    {
        ArgumentExceptionHelper.ThrowIfNull(value);

        _container.RegisterInstance<T>(
            value!,
            ifAlreadyRegistered: IfAlreadyRegistered.AppendNewImplementation);
    }

    /// <inheritdoc/>
    public void RegisterConstant<T>(T? value, string? contract)
        where T : class
    {
        ArgumentExceptionHelper.ThrowIfNull(value);

        if (string.IsNullOrEmpty(contract))
        {
            _container.RegisterInstance<T>(
                value!,
                ifAlreadyRegistered: IfAlreadyRegistered.AppendNewImplementation);
            return;
        }

        _container.RegisterInstance<T>(
            value!,
            ifAlreadyRegistered: IfAlreadyRegistered.Replace,
            serviceKey: contract);
    }

    /// <inheritdoc/>
    public void RegisterLazySingleton<[DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.PublicParameterlessConstructor)] T>(Func<T?> valueFactory)
        where T : class
    {
        ArgumentExceptionHelper.ThrowIfNull(valueFactory);

        _container.RegisterDelegate<T>(
            _ => valueFactory()!,
            Reuse.Singleton,
            ifAlreadyRegistered: IfAlreadyRegistered.AppendNewImplementation);
    }

    /// <inheritdoc/>
    public void RegisterLazySingleton<[DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.PublicParameterlessConstructor)] T>(Func<T?> valueFactory, string? contract)
        where T : class
    {
        ArgumentExceptionHelper.ThrowIfNull(valueFactory);

        if (string.IsNullOrEmpty(contract))
        {
            _container.RegisterDelegate<T>(
                _ => valueFactory()!,
                Reuse.Singleton,
                ifAlreadyRegistered: IfAlreadyRegistered.AppendNewImplementation);
            return;
        }

        _container.RegisterDelegate<T>(
            _ => valueFactory()!,
            Reuse.Singleton,
            ifAlreadyRegistered: IfAlreadyRegistered.Replace,
            serviceKey: contract);
    }

    /// <inheritdoc />
    public void Dispose()
    {
        Dispose(true);
        GC.SuppressFinalize(this);
    }

    /// <summary>
    /// Disposes of the instance.
    /// </summary>
    /// <param name="disposing">Whether or not the instance is disposing.</param>
    protected virtual void Dispose(bool disposing)
    {
        if (disposing)
        {
            try
            {
                _container?.Dispose();
            }
            catch
            {
                // Suppress exceptions from service disposal
            }
        }
    }

    private static object? CreateThenConvert(Type serviceType, Func<object?> factory)
    {
        // we need to cast because we pass an object back and dryioc wants it explicitly cast.
        // alternative (happy to be proven wrong) is to break the interface and add a Register<T>(...) method?
        var instance = factory();

        return instance != null ? Cast(serviceType, instance) : null;
    }

    private static object? Cast(Type type, object data)
    {
        // based upon https://stackoverflow.com/a/27584212
        var dataParam = Expression.Parameter(typeof(object), "data");
        var body = Expression.Block(Expression.Convert(Expression.Convert(dataParam, data.GetType()), type));

        var run = Expression.Lambda(body, dataParam).Compile();
        return run.DynamicInvoke(data);
    }
}
